---
phase: 06-testing-and-quality-gates
plan: 04
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - hooks/useLocalStorage.test.ts
  - contexts/VacationContext.test.tsx
autonomous: true

must_haves:
  truths:
    - "useLocalStorage hook correctly serializes/deserializes vacation data"
    - "VacationContext provides vacation state to consuming components"
    - "VacationContext handles year-aware data loading for historical mode"
  artifacts:
    - path: "hooks/useLocalStorage.test.ts"
      provides: "localStorage hook tests with mocking and serialization"
      min_lines: 60
    - path: "contexts/VacationContext.test.tsx"
      provides: "VacationContext integration tests with provider wrapper"
      min_lines: 80
  key_links:
    - from: "hooks/useLocalStorage.test.ts"
      to: "hooks/useLocalStorage.ts"
      via: "import { useLocalStorage }"
      pattern: "import.*useLocalStorage"
    - from: "contexts/VacationContext.test.tsx"
      to: "contexts/VacationContext.tsx"
      via: "import { VacationProvider, useVacation }"
      pattern: "import.*VacationContext"
---

<objective>
Create integration tests for useLocalStorage hook and VacationContext provider.

Purpose: Verify vacation state management, localStorage persistence, and year-aware context behavior.
Output: Two test files covering hook logic and context integration with mocked dependencies.
</objective>

<execution_context>
@/home/nikolaymih11/.claude/get-shit-done/workflows/execute-plan.md
@/home/nikolaymih11/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-testing-and-quality-gates/06-RESEARCH.md

# Code under test
@hooks/useLocalStorage.ts
@contexts/VacationContext.tsx

# Testing patterns from research
Pattern 2: Testing React Context (Integration Tests)
Pattern 3: Testing with localStorage Mock
</context>

<tasks>

<task type="auto">
  <name>Create useLocalStorage hook test suite</name>
  <files>hooks/useLocalStorage.test.ts</files>
  <action>
Create test suite for hooks/useLocalStorage.ts with localStorage mocking.

Test coverage requirements:
1. **Initial value from localStorage**
   - Key exists: returns parsed value from localStorage
   - Key missing: returns initial value provided
   - Invalid JSON in localStorage: returns initial value (graceful fallback)

2. **setValue updates localStorage**
   - New value serialized to JSON and stored
   - localStorage.setItem called with correct key and value
   - State updates trigger re-render

3. **SSR safety (typeof window check)**
   - Hook doesn't crash when window is undefined
   - Returns initial value in SSR context
   - No localStorage access attempted server-side

4. **Edge cases**
   - Empty array: stores as "[]"
   - Empty string: stores as "\"\""
   - Null value: stores as "null"
   - Complex objects: vacation dates array with ISO strings

Mock localStorage pattern from research:
```typescript
import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { renderHook, act } from '@testing-library/react';
import { useLocalStorage } from '@/hooks/useLocalStorage';

beforeEach(() => {
  const localStorageMock = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    clear: jest.fn(),
  };
  global.localStorage = localStorageMock as any;
});

afterEach(() => {
  global.localStorage.clear();
  jest.clearAllMocks();
});

test('persists vacation dates to localStorage', () => {
  const { result } = renderHook(() => useLocalStorage('vacationDates', []));

  act(() => {
    result.current[1](['2026-03-15']);
  });

  expect(localStorage.setItem).toHaveBeenCalledWith(
    'vacationDates',
    JSON.stringify(['2026-03-15'])
  );
});
```

WHY: localStorage is critical for anonymous users. Must handle SSR safely and serialize data correctly.
  </action>
  <verify>npm test -- useLocalStorage.test.ts</verify>
  <done>useLocalStorage hook tests pass, covering localStorage mocking and SSR safety</done>
</task>

<task type="auto">
  <name>Create VacationContext integration test suite</name>
  <files>contexts/VacationContext.test.tsx</files>
  <action>
Create test suite for contexts/VacationContext.tsx testing provider and consumer integration.

Test coverage requirements:
1. **VacationProvider renders and provides context**
   - Child components can access context via useVacation()
   - Initial state matches defaults (20 totalDays, empty vacationDates)
   - displayYear derived from year prop correctly

2. **Year-aware data loading**
   - Provider with year=2026 loads 2026 vacation data
   - Provider with year=2025 loads 2025 vacation data (historical)
   - isCurrentYear flag is true for current year, false for historical

3. **Read-only mode for historical years**
   - onToggleDate is undefined when viewing historical year
   - onPointerDown/onPointerUp handlers undefined for historical years
   - Read operations (vacationDates, rollover) work for historical years

4. **Rollover calculation**
   - Calls calculateRollover with displayYear (not currentYear)
   - Rollover includes buckets from up to 2 previous years
   - totalRollover excludes expired buckets

5. **Mock Supabase client**
   - VacationContext uses mocked Supabase for data fetching
   - No real database calls during tests

Mock pattern:
```typescript
import { render, screen } from '@testing-library/react';
import { VacationProvider, useVacation } from '@/contexts/VacationContext';

// Mock Supabase
jest.mock('@/lib/supabase/client', () => ({
  createClient: () => ({
    auth: {
      getSession: jest.fn().mockResolvedValue({ data: { session: null } })
    },
    from: jest.fn(() => ({
      select: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn().mockResolvedValue({
        data: { totalDays: 20, vacationDates: [] }
      })
    }))
  })
}));

// Test component that consumes context
function TestConsumer() {
  const { vacationDates, displayYear, isCurrentYear } = useVacation();
  return (
    <div>
      <span data-testid="year">{displayYear}</span>
      <span data-testid="current">{String(isCurrentYear)}</span>
      <span data-testid="count">{vacationDates.length}</span>
    </div>
  );
}

test('provides context values to children', () => {
  render(
    <VacationProvider year={2026}>
      <TestConsumer />
    </VacationProvider>
  );

  expect(screen.getByTestId('year')).toHaveTextContent('2026');
  expect(screen.getByTestId('current')).toHaveTextContent('true');
});
```

IMPORTANT: These are integration tests (components + context), not unit tests of internal functions.

WHY: VacationContext is the heart of vacation state management. Year-aware logic is Phase 5.3 feature.
  </action>
  <verify>npm test -- VacationContext.test.tsx</verify>
  <done>VacationContext tests pass, covering year-aware loading and read-only historical mode</done>
</task>

</tasks>

<verification>
Run all Wave 2 tests together:
```bash
npm test -- "useLocalStorage.test|VacationContext.test"
```

Verify mocks are cleaned up (no test pollution):
```bash
npm test -- --verbose
```

Should show each test suite running independently without state leakage.
</verification>

<success_criteria>
1. useLocalStorage tests pass with localStorage mocking
2. VacationContext tests pass with Supabase mocking
3. Year-aware behavior tested (current vs historical years)
4. Read-only mode verified for historical years
5. No test pollution (mocks cleaned up in afterEach)
6. Tests run in under 10 seconds
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-and-quality-gates/06-04-SUMMARY.md`
</output>
