---
phase: 03-full-year-calendar-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/calendar/bridgeDays.ts
  - lib/calendar/bridgeDays.test.ts
autonomous: true

must_haves:
  truths:
    - "Bridge day detection identifies Monday after Tuesday holiday"
    - "Bridge day detection identifies Friday after Thursday holiday"
    - "Bridge day detection ignores holidays already adjacent to weekends"
    - "Bridge day detection prevents duplicate suggestions for same date"
  artifacts:
    - path: "lib/calendar/bridgeDays.ts"
      provides: "Bridge day detection algorithm"
      exports: ["detectBridgeDays", "isBridgeDay", "BridgeDay"]
      min_lines: 80
    - path: "lib/calendar/bridgeDays.test.ts"
      provides: "Bridge day algorithm tests"
      contains: "describe('detectBridgeDays')"
      min_lines: 50
  key_links:
    - from: "lib/calendar/bridgeDays.ts"
      to: "date-fns"
      via: "parseISO, getISODay, addDays, subDays, format"
      pattern: "import.*from 'date-fns'"
    - from: "lib/calendar/bridgeDays.ts"
      to: "lib/holidays/types.ts"
      via: "Holiday interface import"
      pattern: "import.*Holiday.*from.*holidays/types"
---

<objective>
Create pure bridge day detection logic that identifies optimal vacation opportunities when Bulgarian holidays fall adjacent to weekends (Tuesday or Thursday holidays).

Purpose: Enable yellow bridge day suggestions in calendar (HOL-03 requirement) - users can see when taking one vacation day creates a 4-day weekend.

Output: Tested TypeScript functions that detect bridge days based on holiday dates and day-of-week positioning.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-full-year-calendar---performance**---12-month-view-with-bridge-day-suggestions/03-RESEARCH.md

# Phase 1 foundation
@lib/holidays/types.ts
@lib/calendar/dates.ts

# Bridge day algorithm from research
Research identifies that bridge days only occur when:
- Holiday on Tuesday → Monday before is bridge (creates Sat-Sun-Mon-Tue = 4 days off)
- Holiday on Thursday → Friday after is bridge (creates Thu-Fri-Sat-Sun = 4 days off)

Use date-fns utilities: parseISO, getISODay (Monday=1...Sunday=7), addDays, subDays, format
</context>

<tasks>

<task type="auto">
  <name>Create bridge day detection types and core algorithm</name>
  <files>lib/calendar/bridgeDays.ts</files>
  <action>
Create `lib/calendar/bridgeDays.ts` with:

**Types:**
```typescript
export interface BridgeDay {
  date: string; // ISO format yyyy-MM-dd
  reason: 'holiday-after' | 'holiday-before';
  relatedHoliday: string; // Holiday name
  daysOff: number; // Total consecutive days (always 4)
}
```

**Function: detectBridgeDays(holidays: Holiday[], year: number): BridgeDay[]**
- Filter holidays to target year only (holiday.date.getFullYear() === year)
- For each holiday:
  - Use getISODay() to get day of week (1=Monday, 7=Sunday)
  - If Tuesday (2): Check if Monday before is NOT already a holiday → add as bridge
  - If Thursday (4): Check if Friday after is NOT already a holiday → add as bridge
  - Use subDays(date, 1) for Monday, addDays(date, 1) for Friday
  - Format dates with format(date, 'yyyy-MM-dd')
- Return array of BridgeDay objects with reason and relatedHoliday name

**Function: isBridgeDay(dateStr: string, bridgeDays: BridgeDay[]): boolean**
- Simple lookup: bridgeDays.some(b => b.date === dateStr)
- Used by components to check if a date is a bridge day

**Key rules:**
- Only Tuesday and Thursday holidays create bridges
- Monday/Friday holidays already create 3-day weekends (not bridges)
- Wednesday holidays have no bridge opportunity
- Don't suggest bridge if that day is already a holiday
- Use date-fns for ALL date operations (parseISO, getISODay, addDays, subDays, format)

**Imports:**
- `import { parseISO, getISODay, addDays, subDays, format } from 'date-fns';`
- `import type { Holiday } from '@/lib/holidays/types';`
  </action>
  <verify>
```bash
# File exists and exports types
grep -q "export interface BridgeDay" lib/calendar/bridgeDays.ts
grep -q "export function detectBridgeDays" lib/calendar/bridgeDays.ts
grep -q "export function isBridgeDay" lib/calendar/bridgeDays.ts

# Uses date-fns (not native Date)
grep -q "from 'date-fns'" lib/calendar/bridgeDays.ts

# Has correct logic patterns
grep -q "getISODay" lib/calendar/bridgeDays.ts
grep -q "dayOfWeek === 2" lib/calendar/bridgeDays.ts  # Tuesday check
grep -q "dayOfWeek === 4" lib/calendar/bridgeDays.ts  # Thursday check
```
  </verify>
  <done>
- BridgeDay interface exported with date, reason, relatedHoliday, daysOff fields
- detectBridgeDays() function identifies Tuesday/Thursday holidays and suggests adjacent workdays
- isBridgeDay() helper function for fast lookup
- All date operations use date-fns (parseISO, getISODay, addDays, subDays, format)
- Logic prevents suggesting bridges on dates that are already holidays
  </done>
</task>

<task type="auto">
  <name>Create comprehensive tests for bridge day detection</name>
  <files>lib/calendar/bridgeDays.test.ts</files>
  <action>
Create `lib/calendar/bridgeDays.test.ts` with test cases covering:

**Test Suite: detectBridgeDays()**

1. **Tuesday holiday creates Monday bridge:**
   - Input: Holiday on 2026-01-07 (Tuesday)
   - Expected: Bridge day on 2026-01-06 (Monday) with reason='holiday-after'
   - daysOff: 4

2. **Thursday holiday creates Friday bridge:**
   - Input: Holiday on 2026-01-09 (Thursday)
   - Expected: Bridge day on 2026-01-10 (Friday) with reason='holiday-before'
   - daysOff: 4

3. **Monday holiday creates NO bridge:**
   - Input: Holiday on 2026-01-05 (Monday)
   - Expected: [] (empty array, Monday already extends weekend)

4. **Friday holiday creates NO bridge:**
   - Input: Holiday on 2026-01-03 (Friday)
   - Expected: [] (Friday already extends weekend)

5. **Wednesday holiday creates NO bridge:**
   - Input: Holiday on 2026-01-08 (Wednesday)
   - Expected: [] (no adjacent weekend)

6. **No duplicate bridges if adjacent day is also holiday:**
   - Input: Two holidays on consecutive days (Tuesday + Monday)
   - Expected: No bridge suggested for Monday (it's already a holiday)

7. **Year filtering works correctly:**
   - Input: Holidays in 2025 and 2026, request year 2026
   - Expected: Only 2026 bridges returned

**Test Suite: isBridgeDay()**

1. **Returns true for existing bridge day**
2. **Returns false for non-bridge day**
3. **Handles empty bridge days array**

**Structure:**
```typescript
import { describe, test, expect } from '@jest/globals';
import { detectBridgeDays, isBridgeDay } from './bridgeDays';
import type { Holiday } from '@/lib/holidays/types';

describe('detectBridgeDays', () => {
  test('Tuesday holiday creates Monday bridge', () => {
    const holidays: Holiday[] = [{
      date: '2026-01-07',  // Tuesday
      name: 'Test Holiday',
      type: 'public'
    }];

    const bridges = detectBridgeDays(holidays, 2026);

    expect(bridges).toHaveLength(1);
    expect(bridges[0].date).toBe('2026-01-06'); // Monday
    expect(bridges[0].reason).toBe('holiday-after');
    expect(bridges[0].daysOff).toBe(4);
  });

  // ... more tests
});
```

Use actual 2026 dates, verify day-of-week with calendar if needed.
  </action>
  <verify>
```bash
# Run tests
npm test -- lib/calendar/bridgeDays.test.ts

# Should pass all test cases
echo "Exit code: $?"
```
  </verify>
  <done>
- Tests cover Tuesday → Monday bridge detection
- Tests cover Thursday → Friday bridge detection
- Tests verify Monday/Friday/Wednesday holidays produce no bridges
- Tests verify no duplicate bridges when adjacent day is holiday
- Tests verify year filtering
- All tests pass with npm test
  </done>
</task>

</tasks>

<verification>
Bridge day algorithm implementation complete when:

1. **Type safety:**
   - BridgeDay interface exported with correct fields
   - Functions have proper TypeScript signatures

2. **Correctness:**
   - Tuesday holidays suggest Monday as bridge
   - Thursday holidays suggest Friday as bridge
   - Other weekdays produce no bridge suggestions
   - No bridges suggested if adjacent day already a holiday

3. **Testing:**
   - All edge cases covered (Mon, Tue, Wed, Thu, Fri holidays)
   - Year filtering tested
   - Tests pass without errors

4. **Code quality:**
   - Uses date-fns for all date operations (no native Date math)
   - Follows existing codebase patterns (ISO date strings, parseISO)
   - Pure functions (no side effects, no state)
</verification>

<success_criteria>
**Phase 3 Plan 1 is complete when:**

- [ ] `lib/calendar/bridgeDays.ts` exists and exports BridgeDay, detectBridgeDays, isBridgeDay
- [ ] Bridge detection logic correctly identifies Tuesday → Monday and Thursday → Friday patterns
- [ ] All date operations use date-fns (parseISO, getISODay, addDays, subDays, format)
- [ ] `lib/calendar/bridgeDays.test.ts` exists with comprehensive test coverage
- [ ] All tests pass (`npm test -- lib/calendar/bridgeDays.test.ts`)
- [ ] No bridges suggested for dates that are already holidays
- [ ] Year filtering ensures only target year's bridges are returned
- [ ] Code follows existing patterns from Phase 1 (Safari-safe dates, ISO strings)
</success_criteria>

<output>
After completion, create `.planning/phases/03-full-year-calendar---performance**---12-month-view-with-bridge-day-suggestions/03-01-SUMMARY.md` following the summary template.
</output>
