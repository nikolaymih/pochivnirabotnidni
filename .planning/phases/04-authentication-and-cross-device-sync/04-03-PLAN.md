---
phase: 04-authentication-and-cross-device-sync
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - lib/vacation/sync.ts
  - lib/vacation/migration.ts
  - contexts/VacationContext.tsx
  - components/MigrationReview.tsx
autonomous: true

must_haves:
  truths:
    - "Authenticated user vacation data reads from and writes to Supabase"
    - "Anonymous user vacation data continues to use localStorage (no regression)"
    - "Changes by authenticated users sync to Supabase after 1.5s debounce"
    - "If Supabase sync fails, data silently stays in localStorage"
    - "On first sign-in with existing localStorage data, data migrates to Supabase"
    - "Conflict between localStorage and Supabase data shows review screen"
    - "No conflict (empty localStorage or exact match) skips review screen"
  artifacts:
    - path: "lib/vacation/sync.ts"
      provides: "Supabase CRUD operations for vacation data"
      exports: ["fetchVacationData", "upsertVacationData"]
    - path: "lib/vacation/migration.ts"
      provides: "localStorage to Supabase migration with conflict detection"
      exports: ["migrateLocalStorageToSupabase"]
    - path: "contexts/VacationContext.tsx"
      provides: "Auth-aware vacation state management with debounced sync"
      exports: ["VacationProvider", "useVacation"]
    - path: "components/MigrationReview.tsx"
      provides: "Conflict resolution UI for data merge"
      min_lines: 40
  key_links:
    - from: "contexts/VacationContext.tsx"
      to: "contexts/AuthContext.tsx"
      via: "useAuth hook"
      pattern: "useAuth"
    - from: "contexts/VacationContext.tsx"
      to: "lib/vacation/sync.ts"
      via: "debounced upsert"
      pattern: "upsertVacationData"
    - from: "contexts/VacationContext.tsx"
      to: "lib/vacation/migration.ts"
      via: "migration on first sign-in"
      pattern: "migrateLocalStorageToSupabase"
    - from: "lib/vacation/sync.ts"
      to: "lib/supabase/client.ts"
      via: "Supabase client for DB operations"
      pattern: "createClient"
---

<objective>
Create auth-aware vacation data sync layer with debounced Supabase writes and localStorage migration.

Purpose: This is the core value of Phase 4 - authenticated users get their vacation data stored in Supabase and synced across devices. Anonymous users continue working exactly as before with localStorage. On first sign-in, localStorage data migrates to Supabase with optional conflict resolution.

Output: Supabase sync utilities, migration logic with conflict detection, enhanced VacationContext that switches between localStorage and Supabase based on auth state, and MigrationReview UI component.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-authentication-and-cross-device-sync/04-CONTEXT.md
@.planning/phases/04-authentication-and-cross-device-sync/04-RESEARCH.md
@.planning/phases/04-authentication-and-cross-device-sync/04-01-SUMMARY.md
@.planning/phases/04-authentication-and-cross-device-sync/04-02-SUMMARY.md
@contexts/VacationContext.tsx
@contexts/AuthContext.tsx
@lib/vacation/types.ts
@lib/vacation/storage.ts
@hooks/useLocalStorage.ts
@lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase sync and migration utilities</name>
  <files>
    lib/vacation/sync.ts
    lib/vacation/migration.ts
  </files>
  <action>
    1. Create `lib/vacation/sync.ts`:
       - Import `createClient` from `@/lib/supabase/client`
       - Import `VacationData` from `@/lib/vacation/types`

       Export `fetchVacationData(userId: string, year: number): Promise<VacationData | null>`:
       - Create Supabase client
       - Query `vacation_data` table: `.select('*').eq('user_id', userId).eq('year', year).single()`
       - If data found: map DB row to VacationData interface:
         - `version: 1`
         - `totalDays: row.total_days`
         - `vacationDates: row.vacation_dates` (already string[] from PostgreSQL TEXT[])
       - If not found (PGRST116 error code = no rows): return null
       - On other errors: console.error and return null (silent failure)

       Export `upsertVacationData(userId: string, year: number, data: VacationData): Promise<boolean>`:
       - Create Supabase client
       - Upsert to `vacation_data` table:
         ```
         .upsert({
           user_id: userId,
           year: year,
           total_days: data.totalDays,
           vacation_dates: data.vacationDates,
           updated_at: new Date().toISOString()
         }, { onConflict: 'user_id,year' })
         ```
       - Return true on success, false on error (log to console)

    2. Create `lib/vacation/migration.ts`:
       - Import `VacationData` from `@/lib/vacation/types`
       - Import `fetchVacationData`, `upsertVacationData` from `./sync`
       - Import `VACATION_STORAGE_KEY`, `DEFAULT_VACATION_DATA` from `./storage`

       Define `MigrationResult` type:
       ```typescript
       export type MigrationResult =
         | { status: 'no-local-data' }
         | { status: 'migrated' }
         | { status: 'no-conflict' }
         | { status: 'conflict'; localData: VacationData; cloudData: VacationData; mergedDates: string[] }
         | { status: 'error'; message: string }
       ```

       Export `migrateLocalStorageToSupabase(userId: string, year: number): Promise<MigrationResult>`:
       - Wrap entire function body in try/catch. On catch: return `{ status: 'error', message: error.message }`
       - Read localStorage data:
         ```typescript
         const raw = typeof window !== 'undefined' ? window.localStorage.getItem(VACATION_STORAGE_KEY) : null
         if (!raw) return { status: 'no-local-data' }
         const localData: VacationData = JSON.parse(raw)
         if (localData.vacationDates.length === 0) return { status: 'no-local-data' }
         ```
       - Fetch cloud data: `const cloudData = await fetchVacationData(userId, year)`
       - If no cloud data: upsert localData to Supabase, return `{ status: 'migrated' }`
       - If cloud data exists:
         - Compare vacation dates (Set-based): create Sets of both, check if they're equal
         - Also compare totalDays
         - If equal: return `{ status: 'no-conflict' }`
         - If different: compute merged dates using Set union:
           ```typescript
           const mergedDates = [...new Set([...localData.vacationDates, ...cloudData.vacationDates])].sort()
           return { status: 'conflict', localData, cloudData, mergedDates }
           ```
       - Use Supabase totalDays as authoritative (per RESEARCH.md Open Question 2)
  </action>
  <verify>
    - `npm run build` succeeds
    - `lib/vacation/sync.ts` exports `fetchVacationData` and `upsertVacationData`
    - `lib/vacation/migration.ts` exports `migrateLocalStorageToSupabase` and `MigrationResult` type
    - MigrationResult includes `'error'` status variant for error handling
  </verify>
  <done>
    Sync utilities can read/write vacation data to Supabase vacation_data table. Migration utility detects conflicts between localStorage and cloud data, returning appropriate result for the UI to handle. Errors are caught and returned as a typed result (never thrown).
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance VacationContext for auth-aware data and create MigrationReview</name>
  <files>
    contexts/VacationContext.tsx
    components/MigrationReview.tsx
  </files>
  <action>
    1. Create `components/MigrationReview.tsx`:
       - 'use client' directive
       - Import `VacationData` from `@/lib/vacation/types`
       - Props interface:
         ```typescript
         interface MigrationReviewProps {
           localData: VacationData;
           cloudData: VacationData;
           mergedDates: string[];
           onAccept: (data: VacationData) => void;
           onCancel: () => void;
         }
         ```
       - UX: This is a FIXED-POSITION MODAL OVERLAY that blocks the entire page UI until the user resolves the conflict. The calendar and summary are hidden behind the overlay backdrop.
       - Layout structure:
         ```tsx
         <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
           <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
             {/* Modal content here */}
           </div>
         </div>
         ```
       - Modal content:
         - Title: "Обединяване на данни" (Data merge)
         - Explanatory text: "Намерени са данни и на това устройство, и в облака." (Data found on this device and in cloud)
         - Show side-by-side comparison in a simple list:
           - "На това устройство: {localData.vacationDates.length} дни" (This device)
           - "В облака: {cloudData.vacationDates.length} дни" (Cloud)
           - "Обединени: {mergedDates.length} дни" (Combined)
         - Two action buttons (flex row, gap-3, justify-end):
           - "Обедини" (Merge) - primary button (bg-blue-600 text-white px-4 py-2 rounded):
             calls `onAccept({ version: 1, totalDays: cloudData.totalDays, vacationDates: mergedDates })`
           - "Запази облачните" (Keep cloud) - secondary button (border border-gray-300 px-4 py-2 rounded):
             calls `onAccept(cloudData)`
         - Per CONTEXT.md: "User can approve or edit the merged dataset"
       - Clean Tailwind styling matching existing app aesthetic

    2. Rewrite `contexts/VacationContext.tsx` to be auth-aware:

       STEP 1 - Keep 'use client' directive and update imports:
       ```typescript
       'use client';
       import { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
       import { useLocalStorage } from '@/hooks/useLocalStorage';
       import { useAuth } from '@/contexts/AuthContext';
       import { VacationData } from '@/lib/vacation/types';
       import { VACATION_STORAGE_KEY, DEFAULT_VACATION_DATA } from '@/lib/vacation/storage';
       import { fetchVacationData, upsertVacationData } from '@/lib/vacation/sync';
       import { migrateLocalStorageToSupabase, MigrationResult } from '@/lib/vacation/migration';
       import { useDebounce } from 'use-debounce';
       import { getYear } from 'date-fns';
       import MigrationReview from '@/components/MigrationReview';
       ```

       STEP 2 - Keep the SAME VacationContextType interface (backward compatible):
       ```typescript
       interface VacationContextType {
         vacationData: VacationData;
         setVacationData: (data: VacationData) => void;
       }
       ```
       This MUST remain identical. Plan 04-04 will extend it later.

       STEP 3 - Keep the context creation unchanged:
       ```typescript
       const VacationContext = createContext<VacationContextType | null>(null);
       ```

       STEP 4 - Rewrite VacationProvider with explicit variable naming:
       ```typescript
       export function VacationProvider({ children }: { children: ReactNode }) {
         // === localStorage data (always present, for anonymous AND as fallback) ===
         const [localStorageData, setLocalStorageData] = useLocalStorage<VacationData>(
           VACATION_STORAGE_KEY,
           DEFAULT_VACATION_DATA
         );
         // NOTE: useLocalStorage returns [T, Dispatch<SetStateAction<T>>]
         // localStorageData is the current value, setLocalStorageData updates it

         // === Auth state ===
         const { user, isLoading: authLoading } = useAuth();
         const currentYear = getYear(new Date());

         // === Cloud state (only populated when authenticated) ===
         const [cloudData, setCloudData] = useState<VacationData | null>(null);
         const [isLoadingCloud, setIsLoadingCloud] = useState<boolean>(true);

         // === Migration state ===
         const [migrationResult, setMigrationResult] = useState<MigrationResult | null>(null);
         const [migrationComplete, setMigrationComplete] = useState<boolean>(false);

         // === Derived state ===
         const isAuthenticated = !!user;
         const activeData = isAuthenticated && cloudData ? cloudData : localStorageData;
       ```

       STEP 5 - Add useEffect for loading cloud data on auth change:
       ```typescript
         // Load cloud data when user signs in, clear when signs out
         useEffect(() => {
           if (!user) {
             setCloudData(null);
             setIsLoadingCloud(false);
             setMigrationComplete(false);
             return;
           }
           setIsLoadingCloud(true);
           fetchVacationData(user.id, currentYear)
             .then(data => {
               setCloudData(data || DEFAULT_VACATION_DATA);
             })
             .catch(err => {
               console.error('Failed to fetch cloud data:', err);
               setCloudData(null); // Fall back to localStorage
             })
             .finally(() => {
               setIsLoadingCloud(false);
             });
         }, [user, currentYear]);
       ```

       STEP 6 - Add useEffect for migration (runs once after cloud data loads):
       ```typescript
         // Run migration after cloud data loads (only once per sign-in session)
         useEffect(() => {
           if (!user || isLoadingCloud || migrationComplete) return;
           migrateLocalStorageToSupabase(user.id, currentYear)
             .then(result => {
               if (result.status === 'migrated') {
                 // Data was auto-migrated, refresh cloud data
                 fetchVacationData(user.id, currentYear)
                   .then(d => setCloudData(d || DEFAULT_VACATION_DATA))
                   .catch(err => console.error('Failed to refresh after migration:', err));
               } else if (result.status === 'conflict') {
                 // Show conflict review modal
                 setMigrationResult(result);
               } else if (result.status === 'error') {
                 // Migration failed silently, continue with cloud data as-is
                 console.error('Migration error:', result.message);
               }
               // 'no-local-data' and 'no-conflict' need no action
               setMigrationComplete(true);
             })
             .catch(err => {
               // Catch-all: migration failed, mark complete and continue
               console.error('Migration unexpected error:', err);
               setMigrationComplete(true);
             });
         }, [user, isLoadingCloud, migrationComplete, currentYear]);
       ```

       STEP 7 - Add debounced Supabase sync:
       ```typescript
         // Debounced sync: writes to Supabase 1.5s after last change
         const [debouncedData] = useDebounce(activeData, 1500);
         useEffect(() => {
           if (!user || !migrationComplete) return;
           upsertVacationData(user.id, currentYear, debouncedData)
             .catch(err => console.error('Sync failed, using localStorage:', err));
         }, [debouncedData, user, migrationComplete, currentYear]);
       ```

       STEP 8 - Define setVacationData that updates the right source:
       ```typescript
         // Update the correct data source based on auth state
         const setVacationData = useCallback((data: VacationData) => {
           if (isAuthenticated) {
             setCloudData(data);
           }
           // Always update localStorage too (fallback and for anonymous users)
           setLocalStorageData(data);
         }, [isAuthenticated, setLocalStorageData]);
       ```

       STEP 9 - Define migration resolution handlers:
       ```typescript
         // Handle user accepting a migration resolution
         const handleMigrationAccept = useCallback((data: VacationData) => {
           setCloudData(data);
           setLocalStorageData(data);
           if (user) {
             upsertVacationData(user.id, currentYear, data)
               .catch(err => console.error('Failed to save migration result:', err));
           }
           setMigrationResult(null);
         }, [user, currentYear, setLocalStorageData]);

         const handleMigrationCancel = useCallback(() => {
           // Keep cloud data as-is, dismiss the modal
           setMigrationResult(null);
         }, []);
       ```

       STEP 10 - Render with MigrationReview modal:
       ```tsx
         return (
           <VacationContext.Provider value={{ vacationData: activeData, setVacationData }}>
             {migrationResult?.status === 'conflict' && (
               <MigrationReview
                 localData={migrationResult.localData}
                 cloudData={migrationResult.cloudData}
                 mergedDates={migrationResult.mergedDates}
                 onAccept={handleMigrationAccept}
                 onCancel={handleMigrationCancel}
               />
             )}
             {children}
           </VacationContext.Provider>
         );
       ```
       The MigrationReview renders as a fixed-position modal overlay (z-50) ABOVE the children. The calendar and summary render normally behind the modal backdrop (bg-black/50). Once the user resolves the conflict, MigrationReview unmounts and the full UI is visible and interactive again.

       STEP 11 - Keep the useVacation hook unchanged:
       ```typescript
       export function useVacation() {
         const context = useContext(VacationContext);
         if (!context) {
           throw new Error('useVacation must be used within a VacationProvider');
         }
         return context;
       }
       ```

       IMPORTANT constraints:
       - The exported interface (VacationContextType) MUST stay identical to avoid breaking existing components
       - useVacation() hook stays exactly the same
       - Anonymous flow (no user) must work identically to before (uses localStorage)
       - Per CONTEXT.md: "No sync indicator" and "Optimistic UI"
       - Per CONTEXT.md: "No user-facing error messages or warnings" for failed syncs
       - Per CONTEXT.md: "localStorage persists even after sign-in"
       - All async operations (.then/.catch) must have error handling (no unhandled rejections)
  </action>
  <verify>
    - `npm run build` succeeds with zero TypeScript errors
    - `npm run dev` works for anonymous users (localStorage, no regression)
    - VacationContext exports the same `VacationContextType` interface as before (only `vacationData` and `setVacationData`)
    - MigrationReview component renders as a fixed-position modal overlay (verify className includes "fixed inset-0 z-50")
    - MigrationReview blocks interaction with the calendar until resolved (bg-black/50 backdrop)
    - No TypeScript errors in consuming components: check `FullYearCalendarWrapper.tsx`, `VacationSummary.tsx`, `Calendar.tsx` all compile
    - All useEffect blocks have proper error handling (.catch or try/catch)
    - The useLocalStorage call is preserved with explicit variable names `localStorageData` and `setLocalStorageData`
  </verify>
  <done>
    VacationContext is auth-aware: anonymous users use localStorage (unchanged behavior), authenticated users use Supabase with debounced sync. Migration from localStorage to Supabase happens on first sign-in. Conflicts show a fixed-position modal overlay that blocks the UI until resolved. Failed syncs and migrations silently fall back to localStorage with console.error logging. The MigrationReview modal renders above the page content with a backdrop overlay; calendar and summary are hidden behind it until the user resolves the conflict.
  </done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- Anonymous user flow works unchanged (localStorage)
- VacationContext.tsx exports unchanged `VacationContextType` interface
- `lib/vacation/sync.ts` has Supabase read/write functions
- `lib/vacation/migration.ts` detects conflicts and merges data, handles errors gracefully
- MigrationReview shows as a fixed-position modal overlay when localStorage and Supabase data conflict
- MigrationReview blocks page interaction until user resolves conflict (backdrop overlay)
- Calendar and summary render normally behind the modal backdrop
- Debounced sync runs 1.5s after last change for authenticated users
- All async operations have error handling (no unhandled promise rejections)
</verification>

<success_criteria>
Authenticated users read/write vacation data to Supabase with 1.5s debounced sync. Anonymous users continue using localStorage without regression. On first sign-in, localStorage data migrates to Supabase (auto if no conflict, with modal overlay review if conflict). The MigrationReview is a fixed-position modal that blocks the entire page UI until the user resolves the conflict. Failed syncs and migrations silently fall back to localStorage. The external contract (VacationContextType) is unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-and-cross-device-sync/04-03-SUMMARY.md`
</output>
