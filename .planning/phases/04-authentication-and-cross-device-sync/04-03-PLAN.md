---
phase: 04-authentication-and-cross-device-sync
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - lib/vacation/sync.ts
  - lib/vacation/migration.ts
  - contexts/VacationContext.tsx
  - components/MigrationReview.tsx
autonomous: true

must_haves:
  truths:
    - "Authenticated user vacation data reads from and writes to Supabase"
    - "Anonymous user vacation data continues to use localStorage (no regression)"
    - "Changes by authenticated users sync to Supabase after 1.5s debounce"
    - "If Supabase sync fails, data silently stays in localStorage"
    - "On first sign-in with existing localStorage data, data migrates to Supabase"
    - "Conflict between localStorage and Supabase data shows review screen"
    - "No conflict (empty localStorage or exact match) skips review screen"
  artifacts:
    - path: "lib/vacation/sync.ts"
      provides: "Supabase CRUD operations for vacation data"
      exports: ["fetchVacationData", "upsertVacationData"]
    - path: "lib/vacation/migration.ts"
      provides: "localStorage to Supabase migration with conflict detection"
      exports: ["migrateLocalStorageToSupabase"]
    - path: "contexts/VacationContext.tsx"
      provides: "Auth-aware vacation state management with debounced sync"
      exports: ["VacationProvider", "useVacation"]
    - path: "components/MigrationReview.tsx"
      provides: "Conflict resolution UI for data merge"
      min_lines: 40
  key_links:
    - from: "contexts/VacationContext.tsx"
      to: "contexts/AuthContext.tsx"
      via: "useAuth hook"
      pattern: "useAuth"
    - from: "contexts/VacationContext.tsx"
      to: "lib/vacation/sync.ts"
      via: "debounced upsert"
      pattern: "upsertVacationData"
    - from: "contexts/VacationContext.tsx"
      to: "lib/vacation/migration.ts"
      via: "migration on first sign-in"
      pattern: "migrateLocalStorageToSupabase"
    - from: "lib/vacation/sync.ts"
      to: "lib/supabase/client.ts"
      via: "Supabase client for DB operations"
      pattern: "createClient"
---

<objective>
Create auth-aware vacation data sync layer with debounced Supabase writes and localStorage migration.

Purpose: This is the core value of Phase 4 - authenticated users get their vacation data stored in Supabase and synced across devices. Anonymous users continue working exactly as before with localStorage. On first sign-in, localStorage data migrates to Supabase with optional conflict resolution.

Output: Supabase sync utilities, migration logic with conflict detection, enhanced VacationContext that switches between localStorage and Supabase based on auth state, and MigrationReview UI component.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-authentication-and-cross-device-sync/04-CONTEXT.md
@.planning/phases/04-authentication-and-cross-device-sync/04-RESEARCH.md
@.planning/phases/04-authentication-and-cross-device-sync/04-01-SUMMARY.md
@.planning/phases/04-authentication-and-cross-device-sync/04-02-SUMMARY.md
@contexts/VacationContext.tsx
@contexts/AuthContext.tsx
@lib/vacation/types.ts
@lib/vacation/storage.ts
@hooks/useLocalStorage.ts
@lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase sync and migration utilities</name>
  <files>
    lib/vacation/sync.ts
    lib/vacation/migration.ts
  </files>
  <action>
    1. Create `lib/vacation/sync.ts`:
       - Import `createClient` from `@/lib/supabase/client`
       - Import `VacationData` from `@/lib/vacation/types`

       Export `fetchVacationData(userId: string, year: number): Promise<VacationData | null>`:
       - Create Supabase client
       - Query `vacation_data` table: `.select('*').eq('user_id', userId).eq('year', year).single()`
       - If data found: map DB row to VacationData interface:
         - `version: 1`
         - `totalDays: row.total_days`
         - `vacationDates: row.vacation_dates` (already string[] from PostgreSQL TEXT[])
       - If not found (PGRST116 error code = no rows): return null
       - On other errors: console.error and return null (silent failure)

       Export `upsertVacationData(userId: string, year: number, data: VacationData): Promise<boolean>`:
       - Create Supabase client
       - Upsert to `vacation_data` table:
         ```
         .upsert({
           user_id: userId,
           year: year,
           total_days: data.totalDays,
           vacation_dates: data.vacationDates,
           updated_at: new Date().toISOString()
         }, { onConflict: 'user_id,year' })
         ```
       - Return true on success, false on error (log to console)

    2. Create `lib/vacation/migration.ts`:
       - Import `VacationData` from `@/lib/vacation/types`
       - Import `fetchVacationData`, `upsertVacationData` from `./sync`
       - Import `VACATION_STORAGE_KEY`, `DEFAULT_VACATION_DATA` from `./storage`

       Define `MigrationResult` type:
       ```typescript
       export type MigrationResult =
         | { status: 'no-local-data' }
         | { status: 'migrated' }
         | { status: 'no-conflict' }
         | { status: 'conflict'; localData: VacationData; cloudData: VacationData; mergedDates: string[] }
       ```

       Export `migrateLocalStorageToSupabase(userId: string, year: number): Promise<MigrationResult>`:
       - Read localStorage data:
         ```typescript
         const raw = typeof window !== 'undefined' ? window.localStorage.getItem(VACATION_STORAGE_KEY) : null
         if (!raw) return { status: 'no-local-data' }
         const localData: VacationData = JSON.parse(raw)
         if (localData.vacationDates.length === 0) return { status: 'no-local-data' }
         ```
       - Fetch cloud data: `const cloudData = await fetchVacationData(userId, year)`
       - If no cloud data: upsert localData to Supabase, return `{ status: 'migrated' }`
       - If cloud data exists:
         - Compare vacation dates (Set-based): create Sets of both, check if they're equal
         - Also compare totalDays
         - If equal: return `{ status: 'no-conflict' }`
         - If different: compute merged dates using Set union:
           ```typescript
           const mergedDates = [...new Set([...localData.vacationDates, ...cloudData.vacationDates])].sort()
           return { status: 'conflict', localData, cloudData, mergedDates }
           ```
       - Use Supabase totalDays as authoritative (per RESEARCH.md Open Question 2)
  </action>
  <verify>
    - `npm run build` succeeds
    - `lib/vacation/sync.ts` exports `fetchVacationData` and `upsertVacationData`
    - `lib/vacation/migration.ts` exports `migrateLocalStorageToSupabase` and `MigrationResult` type
  </verify>
  <done>
    Sync utilities can read/write vacation data to Supabase vacation_data table. Migration utility detects conflicts between localStorage and cloud data, returning appropriate result for the UI to handle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance VacationContext for auth-aware data and create MigrationReview</name>
  <files>
    contexts/VacationContext.tsx
    components/MigrationReview.tsx
  </files>
  <action>
    1. Create `components/MigrationReview.tsx`:
       - 'use client' directive
       - Import `VacationData` from `@/lib/vacation/types`
       - Props interface:
         ```typescript
         interface MigrationReviewProps {
           localData: VacationData;
           cloudData: VacationData;
           mergedDates: string[];
           onAccept: (data: VacationData) => void;
           onCancel: () => void;
         }
         ```
       - UI layout (modal overlay or inline card, Claude's discretion on styling):
         - Title: "Обединяване на данни" (Data merge)
         - Show side-by-side comparison:
           - "На това устройство: {localData.vacationDates.length} дни" (This device)
           - "В облака: {cloudData.vacationDates.length} дни" (Cloud)
           - "Обединени: {mergedDates.length} дни" (Combined)
         - Two buttons:
           - "Обедини" (Merge) - calls onAccept with merged data: `{ version: 1, totalDays: cloudData.totalDays, vacationDates: mergedDates }`
           - "Запази облачните" (Keep cloud) - calls onAccept with cloudData
         - Per CONTEXT.md: "User can approve or edit the merged dataset"
       - Clean Tailwind styling matching existing app aesthetic

    2. Rewrite `contexts/VacationContext.tsx` to be auth-aware:
       - 'use client' directive
       - Import `useAuth` from `@/contexts/AuthContext`
       - Import `useLocalStorage` from `@/hooks/useLocalStorage`
       - Import `VACATION_STORAGE_KEY`, `DEFAULT_VACATION_DATA` from `@/lib/vacation/storage`
       - Import `VacationData` from `@/lib/vacation/types`
       - Import `fetchVacationData`, `upsertVacationData` from `@/lib/vacation/sync`
       - Import `migrateLocalStorageToSupabase`, `MigrationResult` from `@/lib/vacation/migration`
       - Import `useDebounce` from `use-debounce`
       - Import `getYear` from `date-fns`

       Keep the same `VacationContextType` interface (backward compatible):
       ```typescript
       interface VacationContextType {
         vacationData: VacationData;
         setVacationData: (data: VacationData) => void;
       }
       ```

       VacationProvider implementation:
       ```
       - Get { user, isLoading: authLoading } from useAuth()
       - Get currentYear = getYear(new Date())
       - Keep useLocalStorage for localStorage data (always, for fallback)
       - Add useState for cloudData (VacationData | null)
       - Add useState for isLoadingCloud (boolean, true initially)
       - Add useState for migrationResult (MigrationResult | null)
       - Add useState for migrationComplete (boolean)

       // Determine active data source
       const isAuthenticated = !!user
       const activeData = isAuthenticated && cloudData ? cloudData : localStorageData

       // Load cloud data on auth change
       useEffect(() => {
         if (!user) {
           setCloudData(null)
           setIsLoadingCloud(false)
           setMigrationComplete(false)
           return
         }
         // Fetch from Supabase
         setIsLoadingCloud(true)
         fetchVacationData(user.id, currentYear)
           .then(data => {
             setCloudData(data || DEFAULT_VACATION_DATA)
             setIsLoadingCloud(false)
           })
       }, [user, currentYear])

       // Run migration after cloud data loads (only once per sign-in)
       useEffect(() => {
         if (!user || isLoadingCloud || migrationComplete) return
         migrateLocalStorageToSupabase(user.id, currentYear)
           .then(result => {
             if (result.status === 'migrated') {
               // Refresh cloud data
               fetchVacationData(user.id, currentYear).then(d => setCloudData(d || DEFAULT_VACATION_DATA))
             } else if (result.status === 'conflict') {
               setMigrationResult(result)
             }
             // 'no-local-data' and 'no-conflict' need no action
             setMigrationComplete(true)
           })
       }, [user, isLoadingCloud, migrationComplete, currentYear])

       // Debounced sync to Supabase
       const [debouncedData] = useDebounce(activeData, 1500)
       useEffect(() => {
         if (!user || !migrationComplete) return
         upsertVacationData(user.id, currentYear, debouncedData)
           .catch(err => console.error('Sync failed, using localStorage:', err))
       }, [debouncedData, user, migrationComplete, currentYear])

       // setVacationData updates the right source
       const setVacationData = (data: VacationData) => {
         if (isAuthenticated) {
           setCloudData(data)
         }
         // Always update localStorage too (fallback and for anonymous)
         setLocalStorageData(data)
       }

       // Handle migration resolution
       const handleMigrationAccept = (data: VacationData) => {
         setCloudData(data)
         setLocalStorageData(data)
         if (user) {
           upsertVacationData(user.id, currentYear, data)
         }
         setMigrationResult(null)
       }

       const handleMigrationCancel = () => {
         setMigrationResult(null)
       }
       ```

       Render:
       ```tsx
       return (
         <VacationContext.Provider value={{ vacationData: activeData, setVacationData }}>
           {migrationResult?.status === 'conflict' && (
             <MigrationReview
               localData={migrationResult.localData}
               cloudData={migrationResult.cloudData}
               mergedDates={migrationResult.mergedDates}
               onAccept={handleMigrationAccept}
               onCancel={handleMigrationCancel}
             />
           )}
           {children}
         </VacationContext.Provider>
       )
       ```

       IMPORTANT constraints:
       - The exported interface (VacationContextType) MUST stay identical to avoid breaking existing components
       - useVacation() hook stays exactly the same
       - Anonymous flow (no user) must work identically to before (uses localStorage)
       - Per CONTEXT.md: "No sync indicator" and "Optimistic UI"
       - Per CONTEXT.md: "No user-facing error messages or warnings" for failed syncs
       - Per CONTEXT.md: "localStorage persists even after sign-in"
  </action>
  <verify>
    - `npm run build` succeeds
    - `npm run dev` works for anonymous users (localStorage, no regression)
    - VacationContext exports the same interface as before
    - MigrationReview component renders with proper Bulgarian labels
    - No TypeScript errors in consuming components (FullYearCalendarWrapper, VacationSummary)
  </verify>
  <done>
    VacationContext is auth-aware: anonymous users use localStorage (unchanged behavior), authenticated users use Supabase with debounced sync. Migration from localStorage to Supabase happens on first sign-in. Conflicts show a review screen. Failed syncs silently fall back to localStorage.
  </done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- Anonymous user flow works unchanged (localStorage)
- VacationContext.tsx exports unchanged `VacationContextType` interface
- `lib/vacation/sync.ts` has Supabase read/write functions
- `lib/vacation/migration.ts` detects conflicts and merges data
- MigrationReview shows when localStorage and Supabase data conflict
- Debounced sync runs 1.5s after last change for authenticated users
</verification>

<success_criteria>
Authenticated users read/write vacation data to Supabase with 1.5s debounced sync. Anonymous users continue using localStorage without regression. On first sign-in, localStorage data migrates to Supabase (auto if no conflict, with review UI if conflict). Failed syncs silently fall back to localStorage. The external contract (VacationContextType) is unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-and-cross-device-sync/04-03-SUMMARY.md`
</output>
