# Plan 01.1: Fix Holiday Date Timezone Bug

**Phase:** 01.1 - Fix Holiday Date Timezone Bug (INSERTED)
**Created:** 2026-01-25
**Status:** ✅ Completed

## Problem

December 31st, 2026 was incorrectly showing as an official holiday ("Нова година" / New Year) when it should not be. The OpenHolidays API correctly returns January 1st, 2027 as New Year's Day, but the date was being shifted backward by one day due to timezone conversion.

**Root Cause:**
The code was using `parseISO(h.startDate).toISOString().split('T')[0]` which:
1. Parsed "2027-01-01" as midnight local time (Bulgaria UTC+2/+3)
2. Converted to UTC: "2026-12-31T22:00:00.000Z" (shifted back 2-3 hours)
3. Extracted date portion: "2026-12-31" ❌

This affected any holiday that fell on January 1st or other dates near timezone boundaries.

## Solution

Remove the unnecessary timezone conversion. The OpenHolidays API already returns dates in `YYYY-MM-DD` format, so we use them directly:

```typescript
// OLD (buggy):
date: parseISO(h.startDate).toISOString().split('T')[0]

// NEW (correct):
date: h.startDate // Already in correct YYYY-MM-DD format from API
```

## Changes Made

### File: `lib/holidays/fetch.ts`

1. **Removed timezone conversion bug**
   - Changed from: `parseISO(h.startDate).toISOString().split('T')[0]`
   - Changed to: `h.startDate` (use API date directly)
   - Removed unused `parseISO` import from date-fns

2. **Enhanced logging for debugging**
   - Added raw API response logging with `JSON.stringify(data, null, 2)`
   - Added detailed processed holidays logging
   - Added specific December 31st check to catch this issue in future
   - Improved error logging with structured prefixes

3. **Improved error handling**
   - Wrapped fallback import in try-catch
   - Return empty array if both API and fallback fail
   - Added console logs at each fallback step

## Verification

**Before fix:**
- Browser console showed: `{name: 'Нова година', date: '2026-12-31', type: 'Public'}`
- December 31st, 2026 displayed as red holiday in calendar

**After fix:**
- December 31st, 2026 is normal workday (no holiday)
- January 1st, 2027 correctly shows as "Нова година" when viewing 2027

**Testing approach:**
1. User reported issue: December 31st showing as holiday
2. Added logging to trace data through the pipeline
3. Discovered raw API response was correct (Jan 1st, 2027)
4. Found timezone conversion bug in date parsing
5. Fixed by using API dates directly
6. Verified with browser console logs

## Impact

- **Bug Severity:** High - incorrect holiday data defeats core purpose of app
- **Affected Dates:** January 1st holidays (potentially other date boundaries)
- **User Impact:** Users would incorrectly treat Dec 31st as official holiday
- **Performance:** Slightly improved (removed unnecessary date parsing)
- **Files Changed:** 1 file (`lib/holidays/fetch.ts`)
- **LOC:** -2 lines (removed import), ~40 lines logging added

## Related

- **Original Phase:** Phase 1 (Foundation & Static Holiday View)
- **Original Plan:** 01-01 (Holiday Data Layer)
- **Requirement:** HOL-02 (Display official Bulgarian holidays)
- **Constraint:** TECH-01 (Safari/Chrome compatibility)
- **Decision:** Use ISO date strings without time component (TECH-07)

## Lessons Learned

1. **Never use `toISOString()` for date-only values** - timezone conversion is inappropriate
2. **When API returns correct format, use it directly** - don't over-process
3. **User bug reports are gold** - this was caught by user observation
4. **Enhanced logging pays off** - made debugging immediate and clear
5. **Date bugs are subtle** - timezone issues hide in plain sight

## Next Steps

- Monitor logs for any other date boundary issues
- Consider adding automated tests for timezone edge cases
- Document this pattern in TECH-07 decision (no toISOString for dates)
