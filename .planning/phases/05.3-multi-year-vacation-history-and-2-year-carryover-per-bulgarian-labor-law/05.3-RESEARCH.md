# Phase 05.3: Multi-year vacation history and 2-year carryover per Bulgarian labor law - Research

**Researched:** 2026-02-09
**Domain:** Multi-year vacation tracking with carryover and legal expiration
**Confidence:** HIGH

## Summary

This phase enables users to view vacation history across years and implements Bulgarian labor law's 2-year carryover expiration rule. The implementation builds on existing year navigation (already functional via YearSelector) and requires multi-year vacation data storage with carryover bucket tracking.

**Key insight:** Year navigation UI already exists and works. The gap is multi-year vacation data persistence and carryover expiry calculations per Bulgarian –ö–æ–¥–µ–∫—Å –Ω–∞ —Ç—Ä—É–¥–∞ Article 155 (2-year limitation from end of allocation year).

**Primary recommendation:** Store vacation data per (user_id, year) in Supabase (already done), extend VacationContext to fetch historical years, implement carryover bucket tracking with YYYY expiry logic, and display breakdown in VacationSummary showing current year allocation + each prior year's carryover with expiry status.

## Legal Foundation: Bulgarian Labor Law

### 2-Year Carryover Expiration Rule

**Authoritative source:** [Annual Leave in Bulgaria: Carryover and Usage - Eurofast](https://eurofast.eu/annual-leave-in-bulgaria-carryover-and-usage/)

**Exact rule:** "Unused paid annual leave or a portion of it expires two years after the year it was accrued, regardless of the reason."

**Counting method:** The 2-year period begins from the end of the calendar year in which leave was allocated.

**Example:**
- 2024 vacation allocation ‚Üí Can be used until 31.12.2026 (end of 2026)
- 2025 vacation allocation ‚Üí Can be used until 31.12.2027 (end of 2027)

**Special case:** When leave is postponed under Article 176, Paragraph 1, expiration timeline shifts to 2 years after the year the postponement reason ceased.

**Implementation constraint:** For v1, implement the standard rule (2 years from end of allocation year). Postponement special case is edge case for future enhancement.

### Carryover Notification Requirement

Employers must notify employees in writing of their annual leave entitlement, including any carryover leave, by January 31st of each year. This suggests the UI should clearly show carryover breakdown.

**Sources:**
- [Annual Leave in Bulgaria: Carryover and Usage - Eurofast](https://eurofast.eu/annual-leave-in-bulgaria-carryover-and-usage/)
- [Bulgaria Leave Laws & Holidays - VacationTracker](https://vacationtracker.io/leave-laws/europe/bulgaria/)
- [Employee Leave Rights Under Bulgarian Labour Law (Guide 2025) - SofiaOffices](https://sofiaoffices.com/blog/Employee-Leave-Rights-Under-Bulgarian-Labour-Law/)

## Existing Architecture Analysis

### What Already Works

**1. Year Navigation (COMPLETE)**
- YearSelector component with prev/next buttons (2020-2030 range)
- URL query param pattern: `/?year=2024` for historical view, `/` for current year
- Server Component fetches holidays for selected year
- Client wrapper already receives `year` prop and passes to calendar

**2. Multi-Year Data Storage (COMPLETE)**
- Supabase schema: `vacation_data` table with `UNIQUE(user_id, year)` constraint
- `fetchVacationData(userId, year)` fetches single year
- `upsertVacationData(userId, year, data)` saves single year

**3. Single-Year Rollover (PARTIAL)**
- `calculateRollover(userId, currentYear)` fetches only `currentYear - 1`
- Returns `RolloverResult` with rolloverDays, previousYearTotal, previousYearUsed
- VacationSummary displays single rollover line: "–ü—Ä–µ—Ö–≤—ä—Ä–ª–µ–Ω–∏ –æ—Ç {year-1}"

### What Needs Extension

**1. VacationContext (CRITICAL GAP)**
- Currently hardcoded to `currentYear = getYear(new Date())`
- Only fetches/syncs current year vacation data
- Needs to accept year parameter and fetch historical data
- Line 33: `const currentYear = getYear(new Date());`
- Line 60: `fetchVacationData(user.id, currentYear)` ‚Äî single year only
- Line 112: `upsertVacationData(user.id, currentYear, debouncedData)` ‚Äî single year only

**2. Rollover Calculation (NEEDS MULTI-BUCKET)**
- Current: Single previous year rollover
- Needed: Multi-bucket rollover with expiry tracking
- Must track: 2024 allocation usable until 2026, 2025 allocation usable until 2027, etc.

**3. VacationSummary (NEEDS BREAKDOWN)**
- Current: Single rollover line if exists
- Needed: Breakdown showing each carryover bucket with expiry status
- Example:
  ```
  –û–±—â–æ –¥–Ω–∏ –∑–∞ –æ—Ç–ø—É—Å–∫: 20 + 5 + 3 = 28
  –¢–µ–∫—É—â–∞ –≥–æ–¥–∏–Ω–∞ (2026): 20
  –ü—Ä–µ—Ö–≤—ä—Ä–ª–µ–Ω–∏ –æ—Ç 2025 (–≤–∞–∂–∏ –¥–æ 31.12.2027): 5
  –ü—Ä–µ—Ö–≤—ä—Ä–ª–µ–Ω–∏ –æ—Ç 2024 (–≤–∞–∂–∏ –¥–æ 31.12.2026): 3
  ```

**4. Calendar Display (NEEDS HISTORICAL RENDER)**
- Line 117: `vacationDates={isCurrentYear ? vacationData.vacationDates : []}`
- Currently shows empty array for historical years
- Needs to fetch and display historical vacation dates
- Interaction should be disabled for past years (view-only)

## Standard Stack

### Core (Already in Use)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| date-fns | Latest (already installed) | Date arithmetic for year boundaries and comparisons | Safari-safe, project standard per TECH-07 |
| Supabase PostgreSQL | Already configured | Multi-year vacation data storage per (user_id, year) | Table structure already supports this |
| React Context | React 19 | Vacation state management | Existing pattern, extend for year parameter |

### Supporting Functions from date-fns
| Function | Purpose | When to Use |
|----------|---------|-------------|
| `getYear(date)` | Extract year number from Date | Already used, continue using |
| `endOfYear(date)` | Calculate expiry boundary (Dec 31 23:59:59) | Carryover expiry calculations |
| `isAfter(date, compareDate)` | Check if carryover expired | Determine if bucket is still usable |
| `parseISO(string)` | Parse YYYY-MM-DD strings | Project standard for Safari compatibility |

**Installation:** No new packages needed. date-fns already installed and `endOfYear`, `isAfter` are part of core.

## Architecture Patterns

### Pattern 1: Multi-Year VacationContext

**Problem:** VacationContext currently hardcoded to current year. Cannot fetch historical vacation data.

**Solution:** Make VacationContext year-aware.

**Approach:**
```typescript
// Current (Phase 4):
const currentYear = getYear(new Date());
fetchVacationData(user.id, currentYear);

// Needed (Phase 5.3):
// Accept year from parent via prop or URL context
interface VacationProviderProps {
  children: ReactNode;
  year?: number; // Optional: defaults to current year
}

export function VacationProvider({ children, year }: VacationProviderProps) {
  const displayYear = year ?? getYear(new Date());

  // Fetch vacation data for displayYear
  fetchVacationData(user.id, displayYear);

  // Only sync CURRENT year (don't sync historical edits)
  const isCurrentYear = displayYear === getYear(new Date());
  if (isCurrentYear && user) {
    upsertVacationData(user.id, displayYear, debouncedData);
  }
}
```

**Trade-offs:**
- ‚úÖ Minimal change to existing architecture
- ‚úÖ Preserves current year behavior (debounced sync)
- ‚úÖ Historical years are read-only (no accidental edits)
- ‚ùå Requires passing year prop through component tree from page.tsx

**Alternative:** Keep VacationContext as current-year-only, create separate `useHistoricalVacation(year)` hook for historical views.
- ‚ùå More complex: two different hooks for same data
- ‚ùå Doesn't fit existing FullYearCalendarWrapper pattern which uses `useVacation()`

**Recommendation:** Extend VacationProvider with optional year prop. Simpler, fits existing patterns.

### Pattern 2: Carryover Bucket Tracking

**Problem:** Current rollover only tracks single previous year. Need to track multiple carryover buckets with individual expiry dates.

**Data structure:**
```typescript
interface CarryoverBucket {
  year: number;              // Allocation year (e.g., 2024)
  rolloverDays: number;      // Unused days from that year
  expiresAt: string;         // YYYY-MM-DD (e.g., "2026-12-31")
  isExpired: boolean;        // Computed: is today after expiresAt?
}

interface RolloverResult {
  buckets: CarryoverBucket[];  // Sorted newest to oldest
  totalRollover: number;       // Sum of non-expired buckets
}
```

**Calculation logic:**
```typescript
export async function calculateRollover(userId: string, currentYear: number): Promise<RolloverResult> {
  const buckets: CarryoverBucket[] = [];
  const today = new Date();

  // Check up to 2 previous years (Bulgarian law: 2-year limitation)
  for (let i = 1; i <= 2; i++) {
    const allocationYear = currentYear - i;
    const prevData = await fetchVacationData(userId, allocationYear);

    if (!prevData) continue;

    const used = prevData.vacationDates.length;
    const rolloverDays = Math.max(0, prevData.totalDays - used);

    if (rolloverDays === 0) continue;

    // Expiry: end of (allocation year + 2)
    const expiryYear = allocationYear + 2;
    const expiresAt = `${expiryYear}-12-31`;
    const isExpired = isAfter(today, parseISO(expiresAt));

    buckets.push({
      year: allocationYear,
      rolloverDays,
      expiresAt,
      isExpired
    });
  }

  const totalRollover = buckets
    .filter(b => !b.isExpired)
    .reduce((sum, b) => sum + b.rolloverDays, 0);

  return { buckets, totalRollover };
}
```

**Why this pattern:**
- ‚úÖ Explicit expiry tracking per bucket
- ‚úÖ Easy to display in UI (map buckets to rows)
- ‚úÖ Automatically handles edge cases (no previous data, zero rollover)
- ‚úÖ Only fetches 2 previous years (performance constraint from Bulgarian law)

### Pattern 3: VacationSummary Carryover Breakdown

**Current:** Single line for rollover
**Needed:** Breakdown per bucket with expiry status

**UI Pattern:**
```tsx
{/* Total Days (Editable for current year only) */}
<div className="flex items-center justify-between">
  <span className="text-sm text-coffee">üìÖ –û–±—â–æ –¥–Ω–∏ –∑–∞ –æ—Ç–ø—É—Å–∫:</span>
  {isCurrentYear && rollover ? (
    <span className="font-semibold text-espresso">
      {vacationData.totalDays} + {rollover.totalRollover} = {effectiveTotal}
    </span>
  ) : (
    <span className="font-semibold text-espresso">{vacationData.totalDays}</span>
  )}
</div>

{/* Carryover Breakdown (Only for authenticated users with carryover) */}
{isAuthenticated && rollover && rollover.buckets.length > 0 && (
  <div className="border-t border-latte pt-2 mt-2">
    <span className="text-xs text-cappuccino font-semibold">–ü—Ä–µ—Ö–≤—ä—Ä–ª–µ–Ω–∏ –¥–Ω–∏:</span>
    {rollover.buckets.map(bucket => (
      <div key={bucket.year} className="flex items-center justify-between mt-1">
        <span className={`text-xs ${bucket.isExpired ? 'text-oat-milk line-through' : 'text-mocha'}`}>
          –û—Ç {bucket.year} (–≤–∞–∂–∏ –¥–æ {bucket.expiresAt.slice(0, 4)}-12-31)
        </span>
        <span className={`text-sm font-semibold ${bucket.isExpired ? 'text-oat-milk line-through' : 'text-mocha'}`}>
          {bucket.rolloverDays}
        </span>
      </div>
    ))}
  </div>
)}
```

**Visual hierarchy:**
1. Top level: Total = current year allocation + active carryover
2. Second level: Breakdown of carryover buckets
3. Visual cues: Expired buckets are grayed out with strikethrough

### Pattern 4: Historical Calendar View (Read-Only)

**Problem:** Calendar shows empty vacation dates for historical years. Users cannot see past vacation data.

**Solution:** Fetch historical vacation data and display, disable interaction.

**Implementation:**
```tsx
// FullYearCalendarWrapper.tsx
const isCurrentYear = year === getYear(new Date());

// Current: vacationDates={isCurrentYear ? vacationData.vacationDates : []}
// Needed:  vacationDates={vacationData.vacationDates}  // Always show

// Disable interaction for historical years
onToggleDate={isCurrentYear ? toggleVacationDate : undefined}
onPointerDown={isCurrentYear ? handlePointerDown : undefined}
// ...etc
```

**Visual distinction for historical years:**
- Keep vacation days blue (same as current year)
- No hover effects on historical vacation days (already handled by undefined handlers)
- Optional: Add subtle opacity to entire historical calendar (e.g., `opacity-90`)

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Date expiry calculations | Custom year arithmetic with edge cases | date-fns `endOfYear`, `isAfter`, `parseISO` | Handles leap years, timezones, Safari compatibility per TECH-07 |
| Carryover bucket sorting | Manual array sorting logic | Array.sort with year comparator | Built-in, readable |
| Year range validation | Custom min/max year checks | Existing YearSelector min/max (2020-2030) | Already validated and user-tested |
| Multi-year data fetching | Promise.all with manual loop | For loop with await (sequential) | Only 2 years max, sequential is clearer |

**Key insight:** Don't over-complicate carryover calculations. Bulgarian law limits to 2 previous years, so maximum 2 fetch operations. Sequential is fine.

## Common Pitfalls

### Pitfall 1: Timezone Shifts in Expiry Checks

**What goes wrong:** Using `new Date()` for "today" in expiry checks causes timezone-dependent behavior. User in Sofia sees different expiry status than same calculation run on server.

**Why it happens:** `new Date()` includes time component, and comparison with ISO date string at midnight can shift based on timezone.

**Prevention:**
```typescript
// ‚ùå BAD: Timezone-dependent
const today = new Date();
const isExpired = isAfter(today, parseISO(expiresAt));

// ‚úÖ GOOD: Normalize to start of day in local timezone
import { startOfDay } from 'date-fns';
const today = startOfDay(new Date());
const isExpired = isAfter(today, parseISO(expiresAt));
```

**Detection:** Test with user timezone set to different offsets (Sofia UTC+2, UTC-5, etc.)

### Pitfall 2: Syncing Historical Year Edits

**What goes wrong:** User navigates to 2024, calendar shows vacation days, user accidentally clicks and modifies 2024 data instead of 2026 data. Syncs to Supabase, corrupts historical record.

**Why it happens:** VacationContext debounced sync doesn't check if year is current year.

**Prevention:**
```typescript
// In VacationContext useEffect for sync:
const isCurrentYear = displayYear === getYear(new Date());

useEffect(() => {
  if (!user || !migrationComplete || !isCurrentYear) return; // Add isCurrentYear check
  upsertVacationData(user.id, displayYear, debouncedData);
}, [debouncedData, user, migrationComplete, displayYear, isCurrentYear]);
```

**Also disable calendar interaction for historical years:**
```tsx
onToggleDate={isCurrentYear ? toggleVacationDate : undefined}
```

**Detection:** Navigate to historical year, click calendar day, check if vacation dates change in Supabase.

### Pitfall 3: Rollover Calculation on Every Render

**What goes wrong:** Calling `calculateRollover()` repeatedly for every calendar render causes excessive Supabase queries and performance degradation.

**Why it happens:** Carryover calculation requires fetching 2 years of vacation data. If called on every VacationSummary render, causes query storm.

**Prevention:** Calculate rollover once in VacationContext (already done in current implementation), store in state, reuse.

**Current implementation already prevents this:**
```typescript
// VacationContext.tsx line 100-106
useEffect(() => {
  if (!user || isLoadingCloud) return;
  calculateRollover(user.id, currentYear)
    .then(result => setRollover(result));
}, [user, isLoadingCloud, currentYear]);
```

**Extension needed:** Recalculate when `displayYear` changes:
```typescript
useEffect(() => {
  if (!user || isLoadingCloud) return;
  calculateRollover(user.id, displayYear)
    .then(result => setRollover(result));
}, [user, isLoadingCloud, displayYear]); // Change currentYear to displayYear
```

**Detection:** Open browser DevTools Network tab, navigate between years, count Supabase requests.

### Pitfall 4: Displaying Expired Carryover in Total

**What goes wrong:** Vacation summary shows `20 + 5 = 25` but the 5 days are expired, so user thinks they have 25 usable days when they only have 20.

**Why it happens:** Forgetting to filter expired buckets when calculating totalRollover.

**Prevention:**
```typescript
// ‚úÖ GOOD: Filter expired before summing
const totalRollover = buckets
  .filter(b => !b.isExpired)
  .reduce((sum, b) => sum + b.rolloverDays, 0);

// ‚ùå BAD: Sum all buckets including expired
const totalRollover = buckets
  .reduce((sum, b) => sum + b.rolloverDays, 0);
```

**Detection:** Mock vacation data with expired carryover (e.g., 2022 vacation in 2026), verify UI shows correct total.

### Pitfall 5: Carryover for Anonymous Users

**What goes wrong:** Anonymous users see carryover UI but rollover is null because localStorage cannot persist multi-year data reliably.

**Why it happens:** Forgetting that rollover only works for authenticated users.

**Current implementation already prevents this:**
```tsx
// VacationSummary.tsx line 125-131
{isAuthenticated && rollover && rolloverDays > 0 && (
  <div>Pr–µ—Ö–≤—ä—Ä–ª–µ–Ω–∏ –æ—Ç {year - 1}: {rolloverDays}</div>
)}
```

**Extension:** Keep same guard for multi-bucket display:
```tsx
{isAuthenticated && rollover && rollover.buckets.length > 0 && (
  <div>Breakdown...</div>
)}
```

**Detection:** Sign out, verify carryover breakdown does not appear.

### Pitfall 6: Forgetting to Update Migration Logic

**What goes wrong:** User signs in with existing 2024 vacation data in localStorage. Migration runs but only migrates to current year (2026), losing 2024 data.

**Why it happens:** Migration logic in `migrateLocalStorageToSupabase` only handles current year.

**Impact:** LOW ‚Äî localStorage was designed for current year only. Historical data wasn't stored there. But document this clearly.

**Prevention:** Add comment in migration.ts clarifying localStorage is current-year-only:
```typescript
/**
 * Migrate localStorage vacation data to Supabase
 *
 * NOTE: localStorage only stores CURRENT YEAR data. Historical years are not
 * migrated because they were never persisted in localStorage.
 */
```

**Detection:** Read migration.ts, verify it only handles current year, confirm this is intentional.

## Code Examples

### Example 1: Extended RolloverResult with Buckets

```typescript
// lib/vacation/rollover.ts

import { fetchVacationData } from './sync';
import { isAfter, parseISO, startOfDay } from 'date-fns';

export interface CarryoverBucket {
  year: number;              // Allocation year (e.g., 2024)
  rolloverDays: number;      // Unused days from that year
  expiresAt: string;         // YYYY-12-31 format
  isExpired: boolean;        // Computed: today > expiresAt
}

export interface RolloverResult {
  buckets: CarryoverBucket[];  // All carryover buckets (newest first)
  totalRollover: number;       // Sum of non-expired buckets only
}

/**
 * Calculate multi-year carryover with 2-year expiration per Bulgarian labor law
 *
 * Bulgarian –ö–æ–¥–µ–∫—Å –Ω–∞ —Ç—Ä—É–¥–∞: Vacation expires 2 years after allocation year.
 * Example: 2024 vacation ‚Üí usable until 31.12.2026
 *
 * @param userId - Supabase user ID
 * @param currentYear - Year to calculate rollover FOR (e.g., 2026)
 * @returns RolloverResult with buckets and total, or null if no carryover
 */
export async function calculateRollover(userId: string, currentYear: number): Promise<RolloverResult | null> {
  const buckets: CarryoverBucket[] = [];
  const today = startOfDay(new Date()); // Normalize to avoid timezone issues

  // Bulgarian law: 2-year limitation, so check previous 2 years only
  for (let i = 1; i <= 2; i++) {
    const allocationYear = currentYear - i;

    // Fetch vacation data for that year
    const prevData = await fetchVacationData(userId, allocationYear);
    if (!prevData) continue; // No data for this year, skip

    // Calculate unused days
    const usedDays = prevData.vacationDates.length;
    const rolloverDays = Math.max(0, prevData.totalDays - usedDays);

    if (rolloverDays === 0) continue; // No carryover from this year

    // Calculate expiry: end of (allocation year + 2)
    const expiryYear = allocationYear + 2;
    const expiresAt = `${expiryYear}-12-31`;
    const expiryDate = parseISO(expiresAt);
    const isExpired = isAfter(today, expiryDate);

    buckets.push({
      year: allocationYear,
      rolloverDays,
      expiresAt,
      isExpired
    });
  }

  // No buckets = no carryover at all
  if (buckets.length === 0) return null;

  // Sort newest to oldest (2025 before 2024)
  buckets.sort((a, b) => b.year - a.year);

  // Calculate total: only non-expired buckets count
  const totalRollover = buckets
    .filter(b => !b.isExpired)
    .reduce((sum, b) => sum + b.rolloverDays, 0);

  return { buckets, totalRollover };
}
```

### Example 2: Year-Aware VacationProvider

```typescript
// contexts/VacationContext.tsx (modifications)

interface VacationProviderProps {
  children: ReactNode;
  year?: number; // Optional: defaults to current calendar year
}

export function VacationProvider({ children, year }: VacationProviderProps) {
  const currentYear = getYear(new Date());
  const displayYear = year ?? currentYear; // Use provided year or current
  const isCurrentYear = displayYear === currentYear;

  // ... existing localStorage setup ...

  // Load cloud data for displayYear
  useEffect(() => {
    if (!user) {
      setCloudData(null);
      setIsLoadingCloud(false);
      return;
    }
    setIsLoadingCloud(true);
    fetchVacationData(user.id, displayYear) // Changed from currentYear
      .then(data => {
        setCloudData(data || DEFAULT_VACATION_DATA);
      })
      .catch(err => {
        console.error('Failed to fetch cloud data:', err);
        setCloudData(null);
      })
      .finally(() => {
        setIsLoadingCloud(false);
      });
  }, [user, displayYear]); // Changed from currentYear

  // Calculate rollover for displayYear
  useEffect(() => {
    if (!user || isLoadingCloud) return;
    calculateRollover(user.id, displayYear) // Changed from currentYear
      .then(result => setRollover(result))
      .catch(err => console.error('Rollover check failed:', err));
  }, [user, isLoadingCloud, displayYear]); // Changed from currentYear

  // CRITICAL: Only sync to Supabase if viewing CURRENT year
  // Historical years are read-only
  const [debouncedData] = useDebounce(activeData, 1500);
  useEffect(() => {
    if (!user || !migrationComplete || !isCurrentYear) return; // Added isCurrentYear check
    upsertVacationData(user.id, displayYear, debouncedData)
      .catch(err => console.error('Sync failed:', err));
  }, [debouncedData, user, migrationComplete, displayYear, isCurrentYear]);

  // ... rest of provider unchanged ...
}
```

### Example 3: VacationSummary Carryover Breakdown

```tsx
// components/VacationSummary.tsx (additions)

const usedDays = vacationData.vacationDates.length;
const totalRollover = rollover?.totalRollover || 0;
const effectiveTotal = vacationData.totalDays + totalRollover;
const remainingDays = effectiveTotal - usedDays;

{/* Total Days with Breakdown */}
<div className="flex items-center justify-between">
  <span className="text-sm text-coffee">üìÖ –û–±—â–æ –¥–Ω–∏ –∑–∞ –æ—Ç–ø—É—Å–∫:</span>
  {isAuthenticated && rollover && totalRollover > 0 ? (
    <span className="font-semibold text-espresso">
      {vacationData.totalDays} + {totalRollover} = {effectiveTotal}
    </span>
  ) : (
    <span className="font-semibold text-espresso">{vacationData.totalDays}</span>
  )}
</div>

{/* Carryover Breakdown */}
{isAuthenticated && rollover && rollover.buckets.length > 0 && (
  <div className="border-t border-latte pt-2 mt-2 space-y-1">
    <span className="text-xs text-cappuccino font-semibold">–î–µ—Ç–∞–π–ª–∏ –Ω–∞ –ø—Ä–µ—Ö–≤—ä—Ä–ª–µ–Ω–∏—Ç–µ –¥–Ω–∏:</span>
    <div className="flex items-center justify-between">
      <span className="text-xs text-coffee">–¢–µ–∫—É—â–∞ –≥–æ–¥–∏–Ω–∞ ({year}):</span>
      <span className="text-sm font-semibold text-espresso">{vacationData.totalDays}</span>
    </div>
    {rollover.buckets.map(bucket => (
      <div key={bucket.year} className="flex items-center justify-between">
        <span className={`text-xs ${bucket.isExpired ? 'text-oat-milk line-through' : 'text-mocha'}`}>
          –ü—Ä–µ—Ö–≤—ä—Ä–ª–µ–Ω–∏ –æ—Ç {bucket.year} {bucket.isExpired ? '(–∏–∑—Ç–µ–∫–ª–∏)' : `(–≤–∞–∂–∏ –¥–æ ${bucket.expiresAt.slice(0, 4)})`}:
        </span>
        <span className={`text-sm font-semibold ${bucket.isExpired ? 'text-oat-milk line-through' : 'text-mocha'}`}>
          {bucket.rolloverDays}
        </span>
      </div>
    ))}
  </div>
)}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single-year vacation tracking | Multi-year with carryover expiry | Phase 5.3 (this phase) | Users can see history and understand carryover lifecycle |
| Simple rollover (previous year only) | Multi-bucket rollover with per-year expiry | Phase 5.3 (this phase) | Legal compliance with Bulgarian –ö–æ–¥–µ–∫—Å –Ω–∞ —Ç—Ä—É–¥–∞ |
| Year navigation without data | Year navigation with historical vacation display | Phase 5.3 (this phase) | Year selector becomes functional for historical view |

**Key architectural shift:** VacationContext from "current year singleton" to "year-parameterized data provider"

## Open Questions

1. **Should expired carryover buckets be hidden or shown with strikethrough?**
   - What we know: Bulgarian law requires notification of carryover including expiry
   - What's unclear: Best UX for expired buckets (visual clutter vs transparency)
   - Recommendation: Show with strikethrough and "(–∏–∑—Ç–µ–∫–ª–∏)" label. Users should see they HAD carryover that expired as historical record.

2. **Should users be able to edit vacation days in historical years?**
   - What we know: Technically possible, just enable interaction for past years
   - What's unclear: Is this a valuable feature or footgun (accidental edits)?
   - Recommendation: NO for v1. Keep historical years read-only. If user needs to correct past data, they can contact support or we add "edit mode" in future phase.

3. **How far back should year navigation go?**
   - What we know: YearSelector currently allows 2020-2030
   - What's unclear: Oldest year users care about for vacation history
   - Recommendation: Keep 2020-2030 range. Most users won't care about vacation data from 2019 (7 years ago, well past 2-year carryover).

4. **Should carryover calculation be cached or always fresh?**
   - What we know: calculateRollover() makes 2 Supabase queries (previous 2 years)
   - What's unclear: Cache duration, invalidation strategy
   - Recommendation: No caching for v1. Rollover calculated once on page load per year, stored in VacationContext state. Good enough. Add caching in future if performance issue arises.

## Sources

### Primary (HIGH confidence)

**Bulgarian Labor Law:**
- [Annual Leave in Bulgaria: Carryover and Usage - Eurofast](https://eurofast.eu/annual-leave-in-bulgaria-carryover-and-usage/) - Authoritative legal analysis, 2-year rule citation
- [Bulgaria Leave Laws & Holidays - VacationTracker](https://vacationtracker.io/leave-laws/europe/bulgaria/) - Confirms Article 155, employer notification requirement
- [Employee Leave Rights Under Bulgarian Labour Law (Guide 2025) - SofiaOffices](https://sofiaoffices.com/blog/Employee-Leave-Rights-Under-Bulgarian-Labour-Law/) - 2025 guide confirming current law

**React Calendar Patterns:**
- [Date Picker with Month and Year Selector - shadcn/ui](https://www.shadcn.io/patterns/date-picker-standard-2) - Year dropdown patterns with Radix UI
- [React Calendar Components: 6 Best Libraries for 2025 - Builder.io](https://www.builder.io/blog/best-react-calendar-component-ai) - Year navigation patterns survey

**date-fns Documentation:**
- [date-fns Documentation - DevDocs](https://devdocs.io/date_fns/) - Comprehensive function reference
- [How to Use date-fns - Squash.io](https://www.squash.io/how-to-use-js-date-fns/) - Year manipulation examples

### Secondary (MEDIUM confidence)

**Supabase Time-Series Data:**
- [Timeseries Data in Postgres - Neon Guides](https://neon.com/guides/timeseries-data) - Indexing and filtering patterns
- [How to Implement Time-Series Data Storage in Supabase - Bootstrapped App](https://bootstrapped.app/guide/how-to-implement-time-series-data-storage-in-supabase) - Multi-year storage best practices

### Tertiary (LOW confidence)

**Vacation Tracking Software:**
- [5 Best Employee PTO Tracking Software of 2026 - Connecteam](https://connecteam.com/employee-pto-tracker/) - Carryover policy patterns (not Bulgaria-specific)
- [Vacation Accrual Rules - ActiPlans](https://www.actiplans.com/blog/vacation-accrual-rules) - General carryover concepts (not legal advice)

## Metadata

**Confidence breakdown:**
- Bulgarian labor law (2-year rule): HIGH - Multiple authoritative sources confirm Article 155 and expiration rule
- Multi-year data storage: HIGH - Existing Supabase schema already supports this, just need to query different years
- Year navigation UI: HIGH - YearSelector already implemented and functional
- Carryover calculation logic: HIGH - Straightforward algorithm, well-defined by law
- UX for carryover breakdown: MEDIUM - No user testing yet, but pattern is standard in HR software

**Research date:** 2026-02-09
**Valid until:** 60 days (Bulgarian labor law changes slowly, tech patterns stable)

**Critical for planning:**
- VacationContext refactoring is the central task ‚Äî all other features depend on year-aware context
- Rollover calculation extension is self-contained ‚Äî doesn't affect other systems
- VacationSummary UI is cosmetic ‚Äî can be iterated after core functionality works
- Calendar historical display is trivial once VacationContext is year-aware
