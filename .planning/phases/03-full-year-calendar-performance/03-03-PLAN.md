---
phase: 03-full-year-calendar-performance
plan: 03
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - components/FullYearCalendar.tsx
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can view all 12 months simultaneously"
    - "Layout is responsive (1 column mobile, 2 tablet, 3 desktop, 4 large)"
    - "Each month shows holidays in red and bridge days in yellow"
    - "Bridge days are calculated once and passed to all months"
    - "Vacation state persists across month boundaries"
  artifacts:
    - path: "components/FullYearCalendar.tsx"
      provides: "12-month grid container with bridge day detection"
      min_lines: 50
      contains: "Array.from({ length: 12 }"
    - path: "app/page.tsx"
      provides: "Full-year calendar integration replacing single month"
      contains: "FullYearCalendar"
  key_links:
    - from: "components/FullYearCalendar.tsx"
      to: "components/MonthGrid.tsx"
      via: "12 month instances"
      pattern: "<MonthGrid"
    - from: "components/FullYearCalendar.tsx"
      to: "lib/calendar/bridgeDays.ts"
      via: "detectBridgeDays call"
      pattern: "detectBridgeDays\\(holidays"
    - from: "app/page.tsx"
      to: "components/FullYearCalendar.tsx"
      via: "Import and render"
      pattern: "import.*FullYearCalendar"
    - from: "app/page.tsx"
      to: "VacationContext"
      via: "Client wrapper reads context and passes vacation data to Server Components"
      pattern: "VacationContextProvider|useVacationContext"
---

<objective>
Create the 12-month full-year calendar view with responsive grid layout and bridge day detection, replacing the single-month Calendar component in the main app.

Purpose: Fulfill CAL-01 requirement (full year view) and HOL-03 requirement (bridge day suggestions), delivering the core differentiator of seeing all holidays at once.

Output: Responsive 12-month calendar that displays holidays in red, bridge days in yellow, and vacation days in blue across the entire year.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-full-year-calendar-performance/03-RESEARCH.md

# Completed in this phase
@.planning/phases/03-full-year-calendar-performance/03-01-PLAN.md
@.planning/phases/03-full-year-calendar-performance/03-02-PLAN.md

# Current app structure
@app/page.tsx
@components/Calendar.tsx
@components/VacationSummary.tsx

# Dependencies
@lib/holidays/fetch.ts
@contexts/VacationContext.tsx

# Responsive grid from research
Mobile (base): grid-cols-1
Tablet (md:768px): grid-cols-2
Desktop (lg:1024px): grid-cols-3
Large (xl:1280px): grid-cols-4
</context>

<tasks>

<task type="auto">
  <name>Create FullYearCalendar component with responsive 12-month grid</name>
  <files>components/FullYearCalendar.tsx</files>
  <action>
Create `components/FullYearCalendar.tsx` as a Server Component:

**Props interface:**
```typescript
interface FullYearCalendarProps {
  year: number;
  vacationDates?: string[]; // Passed from client wrapper component
}
```

**Component logic:**

1. **Fetch holidays (Server Component pattern):**
   ```typescript
   import { getHolidaysForYear } from '@/lib/holidays/fetch';

   export default async function FullYearCalendar({ year, vacationDates = [] }: FullYearCalendarProps) {
     const holidays = await getHolidaysForYear(year);
     // ... rest
   }
   ```

2. **Calculate bridge days once:**
   ```typescript
   import { detectBridgeDays } from '@/lib/calendar/bridgeDays';

   const bridgeDays = detectBridgeDays(holidays, year);
   ```

3. **Render year header:**
   ```typescript
   <h1 className="text-3xl font-bold mb-6">{year}</h1>
   ```

4. **Single-column vertical scroll layout:**
   ```typescript
   <div className="flex flex-col gap-4">
     {Array.from({ length: 12 }, (_, monthIndex) => {
       // Filter holidays for this month
       const monthHolidays = holidays.filter(h => {
         const holidayDate = new Date(h.date);
         return holidayDate.getMonth() === monthIndex;
       });

       // Filter bridge days for this month
       const monthBridges = bridgeDays.filter(b => {
         const bridgeDate = new Date(b.date);
         return bridgeDate.getMonth() === monthIndex;
       });

       // Filter out bridge days where user already has vacation marked
       // Vacation takes priority (per context decision)
       const visibleBridges = monthBridges.filter(bridge =>
         !vacationDates.includes(bridge.date)
       );

       return (
         <MonthGrid
           key={monthIndex}
           year={year}
           month={monthIndex}
           holidays={monthHolidays}
           bridgeDays={visibleBridges}
           vacationDates={vacationDates}
           compact={true}
         />
       );
     })}
   </div>
   ```

5. **Vacation data flow pattern (Server Components cannot access context):**
   - FullYearCalendar is Server Component (cannot use VacationContext directly)
   - vacationDates prop receives data from client wrapper component
   - Client wrapper (created in app/page.tsx integration) reads VacationContext and passes string[] to Server Component
   - FullYearCalendar passes vacationDates to each MonthGrid

**Imports:**
```typescript
import { getHolidaysForYear } from '@/lib/holidays/fetch';
import { detectBridgeDays } from '@/lib/calendar/bridgeDays';
import MonthGrid from './MonthGrid';
```

**Container styling:**
```typescript
<div className="container mx-auto px-4 py-6">
  {/* Year header */}
  {/* 12-month grid */}
</div>
```

**Important considerations:**
- NO 'use client' - Server Component fetches holidays server-side
- Calculate bridge days ONCE for all 12 months (performance optimization)
- Filter holidays and bridges by month before passing to MonthGrid
- Single column layout: flex flex-col (per context decision - vertical scroll, no responsive grid)
- Gap between months: gap-4 (16px spacing)
- vacationDates passed as prop from client wrapper (cannot access context directly)
- Filter out bridge days where vacation exists: vacation color (blue) takes priority over bridge (yellow)
  </action>
  <verify>
```bash
# File exists and is Server Component
test -f components/FullYearCalendar.tsx
! grep -q "'use client'" components/FullYearCalendar.tsx

# Has async function (Server Component pattern)
grep -q "export default async function FullYearCalendar" components/FullYearCalendar.tsx

# Imports bridge day detection
grep -q "detectBridgeDays" components/FullYearCalendar.tsx

# Has 12-month grid
grep -q "Array.from({ length: 12 }" components/FullYearCalendar.tsx

# Single column flex layout
grep -q "flex flex-col" components/FullYearCalendar.tsx

# Accepts vacationDates prop
grep -q "vacationDates" components/FullYearCalendar.tsx
```
  </verify>
  <done>
- FullYearCalendar.tsx created as async Server Component
- Fetches holidays for entire year server-side
- Calculates bridge days once using detectBridgeDays()
- Renders 12 MonthGrid components in responsive grid
- Grid responsive breakpoints: 1/2/3/4 columns (mobile/tablet/desktop/large)
- Filters holidays and bridge days by month before passing to MonthGrid
- Year header displays at top
- Accepts vacationDates prop (passed from client wrapper component)
  </done>
</task>

<task type="auto">
  <name>Integrate FullYearCalendar into main app page with VacationContext wiring</name>
  <files>app/page.tsx</files>
  <action>
Update `app/page.tsx` to replace single-month Calendar with FullYearCalendar:

**Critical: VacationContext wiring pattern (numbered steps)**

Server Components cannot access React Context. This task creates the client wrapper that bridges VacationContext (client state) to FullYearCalendar (Server Component).

**Step 1: Create client wrapper component (CRITICAL - must come first)**
   ```typescript
   'use client';

   import { useVacationContext } from '@/contexts/VacationContext';
   import FullYearCalendar from '@/components/FullYearCalendar';

   function FullYearCalendarWithVacations({ year }: { year: number }) {
     const { vacationDates } = useVacationContext();
     return <FullYearCalendar year={year} vacationDates={vacationDates} />;
   }
   ```

   This client wrapper:
   - Reads vacation state from VacationContext (client-side React context)
   - Converts state to props (vacationDates string[])
   - Passes props to FullYearCalendar Server Component
   - This is the standard Next.js App Router pattern for Server/Client boundaries

**Step 2: Replace Calendar import**
   ```typescript
   // Remove old Calendar import
   // import Calendar from '@/components/Calendar';
   ```

**Step 3: Update layout structure with scrollable calendar and sticky sidebar**
   ```typescript
   export default async function Home() {
     const currentYear = new Date().getFullYear();

     return (
       <main className="min-h-screen">
         <VacationContextProvider>
           {/* Mobile: Stack vertically (summary at top, not sticky) */}
           <div className="lg:hidden">
             <div className="p-4">
               <VacationSummary />
             </div>
             <div className="p-4">
               <FullYearCalendarWithVacations year={currentYear} />
             </div>
           </div>

           {/* Desktop: Scrollable calendar with sticky sidebar */}
           <div className="hidden lg:flex gap-6">
             {/* Left: Scrollable full year calendar */}
             <div className="flex-1 overflow-y-auto p-4">
               <FullYearCalendarWithVacations year={currentYear} />
             </div>

             {/* Right: Sticky sidebar */}
             <div className="w-80 sticky top-0 h-screen overflow-y-auto p-4">
               <VacationSummary />
               {/* Legend stays with summary - already in VacationSummary or create separate component */}
             </div>
           </div>
         </VacationContextProvider>
       </main>
     );
   }
   ```

**Step 4: Verify layout behavior**
   - Mobile: Summary at top (not sticky), then scrollable calendar (per context decision)
   - Desktop: Sticky sidebar on right, scrollable calendar on left
   - Calendar: Single column of months that scrolls
   - Sidebar: Fixed position with vacation summary + legend

**Important:**
- Step 1 (client wrapper) is CRITICAL and must be explicit, not buried in text
- Client wrapper component defined inline in app/page.tsx (not separate file)
- Keep VacationContext provider wrapping the layout
- Keep VacationSummary visible (sidebar on desktop, top on mobile)
- Remove old Calendar component usage
- Use current year dynamically (not hardcoded 2026)

**Pattern explanation:**
Server Components cannot access React Context. The client wrapper component ('use client') reads VacationContext and passes vacation data as props to the Server Component. This bridges the client/server boundary while keeping FullYearCalendar as a Server Component for optimal performance.
  </action>
  <verify>
```bash
# Imports FullYearCalendar
grep -q "FullYearCalendar" app/page.tsx

# Old Calendar import removed
! grep -q "import Calendar from" app/page.tsx || exit 1

# Has client wrapper with VacationContext
grep -q "'use client'" app/page.tsx
grep -q "useVacationContext" app/page.tsx
grep -q "FullYearCalendarWithVacations" app/page.tsx

# Has mobile and desktop layouts
grep -q "lg:hidden" app/page.tsx
grep -q "hidden lg:flex" app/page.tsx
grep -q "sticky" app/page.tsx

# Uses current year or 2026
grep -q "year=" app/page.tsx
```
  </verify>
  <done>
- app/page.tsx imports FullYearCalendar instead of Calendar
- Client wrapper component (FullYearCalendarWithVacations) created as Step 1 to bridge VacationContext and Server Component
- Client wrapper reads useVacationContext() and passes vacationDates as props
- FullYearCalendar displays with current year (dynamic)
- Layout: Mobile has summary at top (not sticky), Desktop has sticky sidebar
- Desktop: Sticky sidebar on right, scrollable single-column calendar on left
- Mobile: Summary at top, scrollable calendar below (per context decision)
- VacationSummary visible in appropriate location per device
- VacationContext provider wraps components
- Old single-month Calendar component removed from page
- Vacation data flows from context through client wrapper to Server Component as props
  </done>
</task>

</tasks>

<verification>
Full-year calendar integration complete when:

1. **12-month view:**
   - All 12 months display simultaneously
   - Months arranged in responsive grid (1/2/3/4 columns)
   - Each month shows correct days for that month

2. **Bridge day suggestions:**
   - Yellow background on bridge days across all months
   - Bridge days only appear on Mondays after Tuesday holidays and Fridays after Thursday holidays
   - No bridge suggestions on dates that are already holidays

3. **Holiday display:**
   - Red background on all Bulgarian holidays
   - Holidays display in correct months

4. **Vacation persistence:**
   - Blue background on marked vacation days
   - Vacation state works across all 12 months
   - VacationSummary updates when vacation days marked

5. **Layout behavior:**
   - Mobile: Single column, summary at top (not sticky), calendar scrolls below
   - Desktop: Single column calendar (scrollable), sticky sidebar on right with summary + legend
   - All devices: Single column of months, vertical scroll through 12 months

6. **Performance:**
   - Bridge days calculated once (not 12 times)
   - Server Component renders holidays server-side
   - No unnecessary client-side JavaScript

7. **Data wiring:**
   - Client wrapper component reads VacationContext
   - Vacation data passed as props to Server Component
   - MonthGrid receives vacation data and renders correctly
</verification>

<success_criteria>
**Phase 3 Plan 3 is complete when:**

- [ ] `components/FullYearCalendar.tsx` exists as async Server Component
- [ ] FullYearCalendar fetches holidays for entire year
- [ ] FullYearCalendar accepts vacationDates prop
- [ ] Bridge days calculated once using detectBridgeDays()
- [ ] 12 MonthGrid components render in single column flex layout
- [ ] Bridge days filtered: vacation dates take priority over bridge suggestions
- [ ] app/page.tsx imports and renders FullYearCalendar
- [ ] Client wrapper component (FullYearCalendarWithVacations) created as explicit Step 1 in Task 2
- [ ] Client wrapper uses useVacationContext() to read vacation state
- [ ] Vacation data passed as props from client wrapper to Server Component
- [ ] Old single-month Calendar removed from app/page.tsx
- [ ] Layout: Desktop has sticky sidebar, Mobile has summary at top (not sticky)
- [ ] Desktop: Scrollable single-column calendar + sticky sidebar with summary
- [ ] Mobile: Summary at top, scrollable calendar below
- [ ] All 12 months visible on page
- [ ] Holidays display in red across all months
- [ ] Bridge days display in yellow across appropriate months
- [ ] Vacation days display in blue when marked
- [ ] Vacation data flows correctly from context through wrapper to display
</success_criteria>

<output>
After completion, create `.planning/phases/03-full-year-calendar-performance/03-03-SUMMARY.md` following the summary template.
</output>
